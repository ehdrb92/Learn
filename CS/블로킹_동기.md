## 블로킹과 동기

블로킹(Blocking)은 특정 작업이 끝나기 전까지 다른 작업을 수행하지 못하도록 막는 것이다. 논블로킹(Non-Blocking)은 특정 작업이 끝나지 않았더라도 다른 작업을 수행하는 것이다. 예를 들어 스레드가 Lock을 획득하지 못할 경우 대기 상태에 들어가게 되는데 이를 블록킹이라고 한다.

동기(Synchronous)는 일련의 작업이 반드시 순서대로 작업이 되도록 하며 특정 작업의 앞선 순서에 있는 작업이 완료되지 않았다면, 해당 작업을 수행하지 않는다. 비동기(Asynchronous)는 반대로 앞선 순서의 작업 완료 여부에 관계없이 수행된다.

## 둘의 조합

블로킹과 동기는 굉장히 유사한 개념이지만 미세하게 다른 점을 가진다. 일반적으로 블로킹과 동기, 논블로킹과 비동기가 함께 동작한다. 모순적일 수 있지만 블로킹일 때 비동기 작업이 될 수 없지만, 동기 작업의 경우 블로킹과 함께 동작할 수도 있고, 논블로킹과 함께 동작할 수 있다.

동기식 호출 방식에서 특정 이벤트가 완료될 때까지 기다리는 경우 블로킹 작업을 수행하여 메서드가 대기 상태에 들어갈 수 있다. 만약 다음 명령을 진행하기 전에 이벤트 발생 여부에 대해 계속해서 반복적으로 확인한다면 이는 논블로킹이 된다. 그리고 호출자 메서드는 이벤트가 완료될 때까지 대기 상태에 들어가지 않는다.

논블로킹 동기방식의 한 예시로 임베디드 시스템의 폴링(Polling)방식을 들 수있다. 임베디드 시스템은 일반적으로 적은 메모리 리소스로 운영되기 때문에 프로세스를 대기 상태로 메모리에 두기에는 제약이 많다. 그래서 논블로킹을 통해 프로세스를 대기상태로 두지 않고 지속적으로 다른 이벤트의 완료 상태를 확인하는 폴링 방식으로 동작한다. 다만 폴링의 경우 CPU가 계속해서 확인 작업을 수행하기 때문에 경우에 따라 CPU 리소스의 낭비가 생길 수 있다.