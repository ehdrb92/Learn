Linux에서 와일드카드는 글로빙 패턴으로도 알려져 있으며, 파일 이름이나 경로에서 다른 문자를 대표하는 기호 또는 기호 집합입니다. 이들은 특정 패턴과 일치하는 파일 이름을 선택하기 위해 명령줄 유틸리티와 함께 사용되며, 여러 파일에 대해 한 번에 작업을 수행하기 쉽게 만듭니다. 언급하신 세 가지 주요 와일드카드—`*`, `?`, `[]`—는 파일 조작 및 검색에서 중요한 역할을 합니다.

### `*` (별표)

- 0개 이상의 문자를 나타냅니다.
- 파일 이름에서 임의의 수의 문자와 일치시키고 싶을 때 사용됩니다. 예를 들어, `*.txt`는 현재 디렉터리의 `.txt` 확장자를 가진 모든 파일, 예를 들어 `notes.txt`, `chapter1.txt` 등과 일치합니다.

### `?` (물음표)

- 정확히 하나의 문자와 일치합니다.
- 한 문자만 다른 특정 패턴의 파일 이름과 일치하는 데 유용합니다. 예를 들어, `chapter?.txt`는 `chapter1.txt`, `chapter2.txt`와 일치하지만 `chapter10.txt`와는 일치하지 않습니다.

### `[]` (대괄호)

- 대괄호 안의 어떤 단일 문자와도 일치합니다.
- 문자의 범위나 문자 목록을 지정할 수 있습니다. 예를 들어:
  - `chapter[1-5].txt`는 `chapter1.txt`부터 `chapter5.txt`까지의 파일과 일치합니다.
  - `chapter[135].txt`는 `chapter1.txt`, `chapter3.txt`, `chapter5.txt`와 일치하지만 `chapter2.txt`나 `chapter4.txt`와는 일치하지 않습니다.

### 고급 와일드카드 패턴

- **`-`로 범위 지정**: 대괄호 안에서 `-`를 사용하여 문자의 범위를 지정할 수 있습니다. 예를 들어, `[a-z]`는 소문자와 일치하고, `[0-9]`는 숫자와 일치합니다.
- **`!` 또는 `^`로 부정**: 대괄호 안의 패턴 시작 부분에 느낌표(`!`)나 캐럿(`^`)을 두면 패턴을 부정하여 나열되지 않은 어떤 문자와도 일치합니다. 예를 들어, `chapter[!1-3].txt`는 `chapter4.txt`와 같은 파일과 일치하지만 `chapter1.txt`, `chapter2.txt`, `chapter3.txt`와는 일치하지 않습니다.

### 예시 및 사용 팁

- **대량 작업**: 와일드카드는 파일 그룹에 대한 작업을 수행하는 데 특히 유용합니다. 예를 들어, 디렉터리의 모든 `.jpg` 파일을 제거하려면 `rm *.jpg`를 사용할 수 있습니다.
- **선택적 작업**: "project"로 시작하는 모든 `.txt` 파일을 다른 디렉터리로 복사하려면 `cp project*.txt /path/to/destination`을 사용할 수 있습니다.
- **복잡한 일치**: 와일드카드를 결합하면 더 복잡한 패턴 일치가 가능합니다. 예를 들어, `chapter[5-9]?.txt`는 `chapter50.txt`부터 `chapter99.txt`까지 일치하지만 `chapter4.txt`나 `chapter100.txt`와는 일치하지 않습니다.

### 중요 고려 사항

- 와일드카드 확장은 명령이 실행되기 전에 셸에 의해 수행됩니다. 이는 명령이 와일드카드 패턴이 아닌 확장된 파일 이름 목록을 보게 된다는 것을 의미합니다.
- 모든 명령이 와일드카드를 동일한 방식으로 해석하는 것은 아니며, 이는 주로 셸이 명령에 전달하기 전에 확장하는 방식에 의해 결정됩니다.
- 파일을 수정하거나 삭제할 수 있는 작업을 수행할 때, 특히 와일드카드를 사용할 때는 주의가 필요합니다. `ls`와 같은 무해한 명령으로 패턴을 테스트한 후 잠재적으로 파괴적인 명령을 진행하는 것이 좋은 관행입니다.

와일드카드는 Linux에서 파일과 디렉터리를 효율적으로 관리하는 데 있어 강력한 기능을 제공하며, 파일 이름과 일치하는 유연하고 강력한 패턴을 제공합니다.

`[]` (대괄호)와 `$(command)`는 각각 독특한 목적을 가지고 Linux 명령줄과 쉘 스크립팅에서 중요한 구성 요소입니다.

### `[]` (대괄호)

Linux에서 대괄호는 여러 맥락에서 사용되며, 맥락에 따라 다른 의미를 가집니다:

1. **파일 이름 일치 (글로빙)**: 이전에 언급했듯이, 대괄호는 명령줄 작업에서 파일 이름을 일치시키기 위한 와일드카드로 사용됩니다. 대괄호 안에서 문자의 범위나 개별 문자 목록을 지정할 수 있습니다. 쉘은 이러한 패턴을 확장하여 파일 이름과 일치시킵니다. 예를 들어, `file[1-3].txt`는 `file1.txt`, `file2.txt`, `file3.txt`와 일치합니다.

2. **조건식 표현**: 쉘 스크립팅에서 대괄호는 조건식을 평가하는 데 사용됩니다. 이는 `test` 명령어와 동의어로, 파일 유형을 확인하거나 문자열을 비교하거나 산술 조건을 평가하는 데 사용됩니다. 예를 들어:

   ```bash
   if [ "$a" -eq "$b" ]; then
       echo "a is equal to b"
   fi
   ```

   이 맥락에서, `[ "$a" -eq "$b" ]`는 변수 `a`와 `b`가 같은지 테스트합니다.

3. **배열**: bash 스크립팅에서 대괄호는 배열 요소에 접근하는 데도 사용됩니다. 예를 들어, `array[0]`은 `array`라는 배열의 첫 번째 요소를 참조합니다.

### `$(command)` (명령어 치환)

명령어 치환을 사용하면 다른 명령어의 인자로 명령어의 출력을 사용할 수 있습니다. 이는 괄호 안의 명령어 출력을 캡처하고 외부 명령어에 대체하는 효과적인 방법입니다. 명령어 치환에는 두 가지 구문이 있습니다:

- `` `command` `` (백틱, 오래된 방법)
- `$(command)` (명확성과 중첩 가능성으로 인해 선호됨)

예시 및 사용법:

- **명령어 출력을 변수에 할당**:

  ```bash
  current_dir=$(pwd)
  ```

  이는 `pwd` (현재 디렉터리 경로)의 출력을 `current_dir` 변수에 할당합니다.

- **명령어 출력을 명령어에서 직접 사용**:

  ```bash
  echo "오늘의 날짜는 $(date)"
  ```

  이 명령어는 `date`를 실행하고, 그 출력을 캡처하여 터미널에 에코된 메시지에 포함합니다.

- **명령어 중첩**: `$(command)` 구문의 장점 중 하나는 백틱을 사용할 때보다 쉽게 중첩할 수 있다는 것입니다. 예를 들어:
  ```bash
  echo "파일 수는 $(ls | wc -l)"
  ```
  이 명령어는 현재 디렉터리의 파일과 디렉터리 수를 `ls`의 출력을 `wc -l`에 파이핑하여 계산하고 결과를 에코합니다.

### 핵심 포인트

- **글로빙 및 조건을 위한 `[]`**: 파일 이름 일치(글로빙)를 위한 대괄호의 사용은 쉘 스크립트 내의 조건식 표현에서의 사용과 구별됩니다.
- **`$(command)`로 명령어 치환**: 이 구문은 한 명령어의 출력을 다른 명령어에 통합하는 데 매우 다양하게 사용될 수 있어, 스크립트에서 동적인 명령어 구성과 실행을 용이하게 합니다.

이러한 구성 요소를 이해하는 것은 보다 동적이고 상호 작용적인 쉘 경험을 가능하게 하는 효과적인 쉘 명령어와 스크립트를 작성하는 데 도움이 됩니다.
