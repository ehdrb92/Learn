크로스 사이트 요청 위조(CSRF)는 최종 사용자가 현재 인증된 웹 애플리케이션에서 원치 않는 작업을 실행하도록 강제하는 사이버 공격의 한 유형입니다. CSRF를 이해하기 위해 개념을 더 관리하기 쉬운 부분으로 나누고 비유를 들어 설명해 보겠습니다.

### 기술적 분석

**웹 애플리케이션 및 세션**: 웹 애플리케이션을 상품을 구매할 수 있는 상점이라고 상상해 보세요. 구매 중인 상품(세션)을 추적하기 위해 스토어는 로그인 시 장바구니(세션 쿠키)를 제공합니다. 이 장바구니는 회원님에게 고유하며, 장바구니에 추가하는 모든 항목이 결제할 때까지 그대로 유지됩니다.

**CSRF 공격**: CSRF 공격은 누군가가 회원님을 속여 회원님도 모르게 장바구니에 상품을 추가하는 경우에 발생합니다. 예를 들어 "무료 쿠폰을 받으려면 여기를 클릭하세요"라는 링크가 포함된 이메일을 받았다고 가정해 보겠습니다. 이 링크를 클릭하면 스토어에서 사용자의 장바구니를 인식하여 제품 구매와 같은 작업이 스토어 웹사이트에서 실행됩니다. 문제는 이러한 행동이 사용자가 의도하거나 승인한 것이 아니라는 것입니다.

### CSRF 작동 방식

1. **사용자 인증**: 사용자가 웹 애플리케이션에 로그인하면 애플리케이션이 쿠키로 식별되는 세션을 생성합니다.

2. **공격 준비**: 공격자는 악성 링크, 이메일 또는 대상 사이트(사용자가 인증된 사이트)로의 요청이 포함된 웹사이트를 준비합니다. 이 요청은 송금, 비밀번호 변경 등을 위한 것일 수 있습니다.

3. **실행**: 공격 대상 사이트에서 이미 인증된 사용자가 악성 링크를 클릭하거나 공격자가 준비한 웹사이트를 방문합니다.

4. **의도하지 않은 요청**: 공격자의 속임수를 통해 사용자가 시작한 요청을 공격 대상 사이트가 수신하고 사용자의 세션 쿠키와 함께 제공되므로 이를 정상적인 작업으로 처리합니다.

### 보호 메커니즘

- **토큰 유효성 검사**: 웹 애플리케이션은 각 요청에 예측할 수 없는 비밀 토큰을 요구함으로써 CSRF 공격으로부터 보호할 수 있습니다. 이 토큰은 사용자의 브라우저와 웹 애플리케이션만 알 수 있으므로 공격자가 요청을 위조하기 어렵습니다.

- **Same-Site Cookies**: 동일한 사이트에서 시작된 요청에만 쿠키가 전송되도록 설정하면(동일 사이트 속성) 외부 사이트에서 시작된 요청에는 쿠키가 첨부되지 않으므로 CSRF의 위험을 줄일 수 있습니다.

- **Referer Check**: 들어오는 요청의 리퍼러 헤더를 확인하면 요청이 외부 사이트가 아닌 사이트 자체에서 오는지 확인할 수 있습니다.

### 비유

CSRF는 누군가 은행으로 주소가 적힌 우표가 붙은 봉투를 보내 내 계좌에서 자신의 계좌로 돈을 이체하라고 지시하는 것이라고 생각하면 됩니다. 사용자가 무의식적으로 봉투에 서명하고 보내면 은행은 사용자가 보낸 것처럼 보이므로 이를 합법적인 요청으로 처리합니다. 보호 메커니즘은 사용자와 은행 사이에 비밀 악수를 추가하는 것과 같으며, 올바른 악수를 한 요청만 승인됩니다.

계속 진행하기 전에 HTTP 요청, 쿠키, 세션 관리와 같은 개념에 대해 얼마나 잘 알고 계신가요? 이렇게 하면 이해의 공백을 메우기 위해 맞춤 설명을 하는 데 도움이 될 것입니다.

세션 쿠키 대신 JWT(JSON 웹 토큰)와 같은 토큰을 인증에 사용하면 CSRF(사이트 간 요청 위조) 공격의 위험을 완화할 수 있지만 그 자체로는 완전한 방어책이 될 수 없습니다. 그 이유와 토큰 기반 인증을 사용하더라도 CSRF가 여전히 문제가 될 수 있는 방법에 대해 자세히 알아보겠습니다.

### 토큰 기반 인증과 CSRF

JWT를 사용하는 시스템과 같은 토큰 기반 인증 시스템에서는 서버가 세션 상태를 저장하지 않습니다. 대신 인증에 성공하면 클라이언트에 토큰을 발급합니다. 이 토큰에는 사용자에 대한 모든 필요한 정보가 포함되어 있으며 일반적으로 클라이언트 측의 로컬 스토리지 또는 인메모리 스토리지에 저장됩니다.

클라이언트는 요청을 할 때 요청 헤더에 토큰을 수동으로 첨부해야 합니다. 이 프로세스는 브라우저가 쿠키를 설정한 도메인에 대한 모든 요청에 세션 쿠키를 자동으로 첨부하는 쿠키 기반 인증과는 근본적으로 다릅니다.

### JWT를 사용하면 CSRF의 위험이 줄어드는 이유

CSRF 공격은 브라우저의 자동 동작을 악용하여 도메인에 대한 모든 요청에 쿠키를 포함합니다. JWT는 요청에 수동으로 첨부해야 하므로(일반적으로 "권한 부여" 헤더에), CSRF 공격은 악성 사이트의 위조된 요청에 이 토큰을 자동으로 포함시키지 않습니다. 따라서 애플리케이션이 사용자 세션 유지를 위해 쿠키 외부에 저장된 JWT만 사용하는 경우, 본질적으로 기존의 CSRF 공격 벡터를 피할 수 있습니다.

### 남은 위험 및 고려 사항

그러나 JWT를 사용한다고 해서 CSRF 보호의 필요성이 완전히 제거되지 않는 시나리오도 있습니다:

- **JWT in Cookies**: 세션을 유지하기 위해 쿠키에 JWT를 저장하는 경우, 특히 해당 쿠키가 `HttpOnly` 및 `SameSite`와 같은 속성으로 제대로 보호되지 않는 경우 CSRF 공격에 취약할 수 있습니다. 이 저장 방법은 단순성 또는 레거시 시스템 지원을 위해 선택될 수 있습니다.

- **Other Attack Vectors**: CSRF는 완화될 수 있지만, XSS(크로스 사이트 스크립팅) 공격을 통한 토큰 도용과 같이 JWT에서 발생하는 다른 보안 문제를 고려해야 합니다. 토큰을 안전하게 취급하고 저장하는 것이 중요합니다.

- **Best Practices**: JWT를 사용하여 CSRF 공격을 완화한 경우에도 cross-origin 요청에 대해 'Origin' 및 'Referer' 헤더를 확인하는 등의 추가 보안 조치를 구현하면 보안을 한층 더 강화할 수 있습니다.

### 결론

JWT와 같은 토큰 기반 인증은 CSRF 공격의 위험을 줄이기는 하지만 경계와 보안 모범 사례의 필요성을 완전히 없애지는 못합니다. 구체적인 위험을 이해하고 인증 방법에 맞는 포괄적인 보안 조치를 구현하는 것이 중요합니다.

계속 진행하기 전에 토큰 기반 인증의 작동 방식에 대해 궁금한 점이 있거나 JWT의 맥락에서 CSRF 보호 전략에 대한 자세한 정보를 얻고 싶으신가요?
